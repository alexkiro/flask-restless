"""
    tests.test_fetching
    ~~~~~~~~~~~~~~~~~~~

    Provides tests for fetching resources from endpoints generated by
    Flask-Restless.

    This module includes tests for additional functionality that is not already
    tested by :mod:`test_jsonapi`, the module that guarantees Flask-Restless
    meets the minimum requirements of the JSON API specification.

    :copyright: 2015 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com> and
                contributors.
    :license: GNU AGPLv3+ or BSD

"""
from datetime import date
from datetime import datetime
from datetime import time

try:
    from flask.ext.sqlalchemy import SQLAlchemy
except:
    has_flask_sqlalchemy = False
else:
    has_flask_sqlalchemy = True
from sqlalchemy import Column
from sqlalchemy import Date
from sqlalchemy import DateTime
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import Time
from sqlalchemy import Unicode
from sqlalchemy.orm import backref
from sqlalchemy.orm import relationship

from flask.ext.restless import APIManager
from flask.ext.restless import CONTENT_TYPE

from .helpers import FlaskTestBase
from .helpers import loads
from .helpers import MSIE8_UA
from .helpers import MSIE9_UA
from .helpers import ManagerTestBase
from .helpers import skip_unless
from .helpers import unregister_fsa_session_signals


class TestFetching(ManagerTestBase):
    """Tests for fetching resources."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`TestSupport.Person`
        and :class:`TestSupport.Article` models.

        """
        super(TestFetching, self).setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            title = Column(Unicode, primary_key=True)

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            bedtime = Column(Time)
            birth_datetime = Column(DateTime)
            birthday = Column(Date)

        class Tag(self.Base):
            __tablename__ = 'tag'
            name = Column(Unicode, primary_key=True)

        self.Article = Article
        self.Person = Person
        self.Tag = Tag
        self.Base.metadata.create_all()
        self.manager.create_api(Article)
        self.manager.create_api(Person)
        self.manager.create_api(Tag)

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.Base.metadata.drop_all()

    def test_serialize_time(self):
        """Test for getting the JSON representation of a time field."""
        now = datetime.now().time()
        person = self.Person(id=1, bedtime=now)
        self.session.add(person)
        self.session.commit()
        response = self.app.get('/api/person/1')
        assert response.status_code == 200
        document = loads(response.data)
        person = document['data']
        assert person['bedtime'] == now.isoformat()

    def test_serialize_datetime(self):
        """Test for getting the JSON representation of a datetime field."""
        now = datetime.now()
        person = self.Person(id=1, birth_datetime=now)
        self.session.add(person)
        self.session.commit()
        response = self.app.get('/api/person/1')
        assert response.status_code == 200
        document = loads(response.data)
        person = document['data']
        assert person['birth_datetime'] == now.isoformat()

    def test_serialize_date(self):
        """Test for getting the JSON representation of a date field."""
        now = datetime.now().date()
        person = self.Person(id=1, birthday=now)
        self.session.add(person)
        self.session.commit()
        response = self.app.get('/api/person/1')
        assert response.status_code == 200
        document = loads(response.data)
        person = document['data']
        assert person['birthday'] == now.isoformat()

    # def test_num_results(self):
    #     """Tests that a request for (a subset of) all instances of a model
    #     includes the total number of results as part of the JSON response.

    #     """
    #     self.manager.create_api(self.Person)
    #     for i in range(15):
    #         d = dict(name='person{0}'.format(i))
    #         response = self.app.post('/api/person', data=dumps(d))
    #         assert response.status_code == 201
    #     response = self.app.get('/api/person')
    #     assert response.status_code == 200
    #     data = loads(response.data)
    #     assert data['meta']['num_results'] == 15

    def test_alternate_primary_key(self):
        """Tests that models with primary keys that are not named ``id`` are
        are still accessible via their primary keys.

        """
        tag = self.Tag(name=u'foo')
        self.session.add(tag)
        self.session.commit()
        response = self.app.get('/api/tag/foo')
        document = loads(response.data)
        tag = document['data']
        assert tag['id'] == 'foo'

    def test_primary_key_int_string(self):
        """Tests for getting a resource that has a string primary key,
        including the possibility of a string representation of a number.

        """
        tag = self.Tag(name=u'1')
        self.session.add(tag)
        self.session.commit()
        response = self.app.get('/api/tag/1')
        document = loads(response.data)
        tag = document['data']
        assert tag['name'] == '1'

    def test_jsonp(self):
        """Test for a JSON-P callback on a single resource request."""
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person/1?callback=foo')
        assert response.data.startswith(b'foo(')
        assert response.data.endswith(b')')
        document = loads(response.data[4:-1])
        person = document['data']
        assert person['id'] == '1'

    def test_jsonp_collection(self):
        """Test for a JSON-P callback on a collection of resources."""
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person?callback=foo')
        assert response.data.startswith(b'foo(')
        assert response.data.endswith(b')')
        document = loads(response.data[4:-1])
        people = document['data']
        assert ['1', '2'] == sorted(person['id'] for person in people)

    def test_callable_query_attribute(self):
        """Tests that a callable model.query attribute is being used when
        available.

        """

        def query(cls):
            return self.session.query(cls).filter(self.Person.id > 1)

        self.Person.query = classmethod(query)
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person')
        document = loads(response.data)
        people = document['data']
        assert ['2'] == sorted(person['id'] for person in people)

    def test_specified_primary_key(self):
        """Tests that models with more than one primary key are accessible via
        a primary key specified by the server.

        """
        article = self.Article(id=1, title='foo')
        self.session.add(article)
        self.session.commit()
        self.manager.create_api(self.Article, url_prefix='/api2',
                                primary_key='title')
        response = self.app.get('/api2/article/1')
        assert response.status_code == 404
        response = self.app.get('/api2/article/foo')
        assert response.status_code == 200
        document = loads(response.data)
        resource = document['data']
        # Resource objects must have string IDs.
        assert resource['id'] == str(article.id)
        assert resource['title'] == article.title

    def test_correct_content_type(self):
        """Tests that the server responds with :http:status:`200` if the
        request has the correct JSON API content type.

        """
        response = self.app.get('/api/person', content_type=CONTENT_TYPE)
        assert response.status_code == 200
        assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_no_content_type(self):
        """Tests that the server responds with :http:status:`415` if the
        request has no content type.

        """
        response = self.app.get('/api/person', content_type=None)
        assert response.status_code == 415
        assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_wrong_content_type(self):
        """Tests that the server responds with :http:status:`415` if the
        request has the wrong content type.

        """
        bad_content_types = ('application/json', 'application/javascript')
        for content_type in bad_content_types:
            response = self.app.get('/api/person', content_type=content_type)
            assert response.status_code == 415
            assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_msie8(self):
        """Tests for compatibility with Microsoft Internet Explorer 8.

        According to issue #267, making requests using JavaScript from MSIE8
        does not allow changing the content type of the request (it is always
        ``text/html``). Therefore Flask-Restless should ignore the content type
        when a request is coming from this client.

        """
        headers = {'User-Agent': MSIE8_UA}
        content_type = 'text/html'
        response = self.app.get('/api/person', headers=headers,
                                content_type=content_type)
        assert response.status_code == 200

    def test_msie9(self):
        """Tests for compatibility with Microsoft Internet Explorer 9.

        According to issue #267, making requests using JavaScript from MSIE9
        does not allow changing the content type of the request (it is always
        ``text/html``). Therefore Flask-Restless should ignore the content type
        when a request is coming from this client.

        """
        headers = {'User-Agent': MSIE9_UA}
        content_type = 'text/html'
        response = self.app.get('/api/person', headers=headers,
                                content_type=content_type)
        assert response.status_code == 200


class TestDynamicRelationships(ManagerTestBase):
    """Tests for fetching resources from dynamic relationships."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`TestSupport.Person`
        and :class:`TestSupport.Article` models.

        """
        super(TestDynamicRelationships, self).setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            author_id = Column(Integer, ForeignKey('person.id'))
            author = relationship('Person', backref=backref('articles',
                                                            lazy='dynamic'))

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)

        self.Article = Article
        self.Person = Person
        self.Base.metadata.create_all()
        self.manager.create_api(Article)
        self.manager.create_api(Person)

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.Base.metadata.drop_all()

    def test_to_many(self):
        """Tests for fetching a resource with a dynamic link to a to-many
        relation.

        """
        person = self.Person(id=1)
        article1 = self.Article(id=1)
        article2 = self.Article(id=2)
        article1.author = person
        article2.author = person
        self.session.add_all([person, article1, article2])
        self.session.commit()
        response = self.app.get('/api/person/1')
        document = loads(response.data)
        person = document['data']
        links = person['links']
        articles = links['articles']
        print(articles)
        assert ['1', '2'] == sorted(articleid for articleid in articles['ids'])

    def test_to_many_resource_url(self):
        """Tests for fetching a resource with a dynamic link to a to-many
        relation from the related resource URL.

        """
        person = self.Person(id=1)
        article1 = self.Article(id=1)
        article2 = self.Article(id=2)
        article1.author = person
        article2.author = person
        self.session.add_all([person, article1, article2])
        self.session.commit()
        response = self.app.get('/api/person/1/articles')
        document = loads(response.data)
        articles = document['data']
        assert ['1', '2'] == sorted(article['id'] for article in articles)


@skip_unless(has_flask_sqlalchemy, 'Flask-SQLAlchemy not found.')
class TestFlaskSqlalchemy(FlaskTestBase):
    """Tests for fetching resources defined as Flask-SQLAlchemy models instead
    of pure SQLAlchemy models.

    """

    def setUp(self):
        """Creates the Flask-SQLAlchemy database and models."""
        super(TestFlaskSqlalchemy, self).setUp()
        self.db = SQLAlchemy(self.flaskapp)
        self.session = self.db.session

        class Person(self.db.Model):
            id = self.db.Column(self.db.Integer, primary_key=True)

        self.Person = Person
        self.db.create_all()
        self.manager = APIManager(self.flaskapp, flask_sqlalchemy_db=self.db)
        self.manager.create_api(self.Person)

    def tearDown(self):
        """Drops all tables."""
        self.db.drop_all()
        unregister_fsa_session_signals()

    def test_fetch_resource(self):
        """Test for fetching a resource."""
        person = self.Person(id=1)
        self.session.add(person)
        self.session.commit()
        response = self.app.get('/api/person/1')
        document = loads(response.data)
        person = document['data']
        assert person['id'] == '1'
        assert person['type'] == 'person'

    def test_fetch_collection(self):
        """Test for fetching a collection of resource."""
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person')
        document = loads(response.data)
        people = document['data']
        assert ['1', '2'] == sorted(person['id'] for person in people)
